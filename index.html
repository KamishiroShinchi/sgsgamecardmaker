<!DOCTYPE html>
<html lang="en">
<link rel="manifest" href="/manifest.json">
<head>
    <meta charset="UTF-8">
    <meta name="baidu-site-verification" content="code-47W064y9OA" />
    <meta name="google-site-verification" content="ZpFUNCZeahHVij6m_IJwEYWVcJUw0TpGKBv_riJRPu4" />
    <title>三国杀卡牌制作器</title>
    <link rel="stylesheet" type="text/css" href="index.css">
    <link rel="shortcut icon" type="image/x-icon" href="resources/icon.png">
    <script type="text/javascript" src="./jquery-3.6.0.min.js"></script>
</head>
<body>
<nav id="global_nav">
  <ul id="nav_ul">
    <li><a class="barText" style="display: none" href="#" id="AppName"></a></li>
    <li><a class="barText" style="display: none" href="https://www.bilibili.com/video/BV19P4y1j7n6/" target="_blank">反馈建议</a></li>
    <li><a class="barText" href="https://lycium-card-maker-8ec4cf5586b107-1253139667.tcloudbaseapp.com/" target="_blank">本应用基于Lyciumaker 点击此处访问</a></li>
    <li><a class="barText" style="display: none" href="#" style="display: none">投喂开发者</a></li>
  </ul>
</nav>

<div id="cardAndEditor">

<canvas id="card_preview">
</canvas>

<div id="editor">
    <div class="block" style="display: none">
        <div class="verticalBlock">
            <button id="download_card"style="display: none">将卡牌下载到本地</button>
        </div>
    </div>
    <div id="illustration_scaling" class="block">
        <div class="verticalBlock">
            <div class="description  leftDescription" style="display: none">选择插画</div>
            <input type="file" class="function_button" id="import_illustration" accept="image/jpeg, image/png"></button>
        </div>
        <div class="verticalBlock">
            <div class="description  leftDescription">插画缩放</div>
            <input type="number" id="scale_number" onfocus="this.select()" value="100">
            <div class="description">%</div>
            <button id="zoom_out">-25%</button>
            <button id="zoom_in">+25%</button>
            <button id="reset_scale">重置</button>
        </div>
        <div class="verticalBlock">
            <div class="tip">拖拽图片可改变插画位置</div>
        </div>
    </div>
    <div class="block">
        <input type="checkbox" id="translateBox" checked="checked" value="first_checkbox">
        <label class="description" for="translateBox">自动简繁转换</label>
        <div class="tip" id="s2ttip">由于简体繁体并非一一对应，自动简繁转换可能会出现错误，如有错误建议关闭此选项并使用繁体输入</div>
    </div>
 
    <div class="block" style="display: none">
        <div class="verticalBlock">
             <div class="description  leftDescription">武将称号</div>
            <input id="hero_title" class="nearDes" type="text" onfocus="this.select()" value="">
            <div class="tip traditional_please" style="display: none">请输入繁体</div>
        </div>
    </div>
    <div class="block">
        <div class="verticalBlock">
            <div  class="description  leftDescription">卡牌名称</div>
            <input id="hero_name" type="text" onfocus="this.select()" value="">
            <div class="tip traditional_please" style="display: none">请输入繁体</div>
        </div>
    </div>
    <div class="block">
        <div class="verticalBlock">
            <div class="description  leftDescription">背景</div>
            <select id="power_select">
                <option value ="魏" selected="selected">1</option>
                <option value ="蜀">2</option>
                <option value="吴">3</option>
            </select>
        </div>
        <div class="verticalBlock"  style="display: none">
            <div class="leftDescription">
                <input type="checkbox" id="myLord" value="first_checkbox">
                <label class="description" for="myLord">主公</label>
            </div>
        </div>
    </div>
    <div class="block" style="display: none">
        <div class="verticalBlock">
            <div class="description leftDescription">体力值</div>
            <input id="heart" type="number" value="4" onfocus="this.select()">
        </div>
        <div class="verticalBlock">
            <input type="checkbox" id="isHeartLimit" value="first_checkbox">
            <label class="description" for="isHeartLimit">体力值与体力上限不等</label>
        </div>
        <div class="verticalBlock" id="heartLimitVBlock" style="display: none">
            <div class="description leftDescription">体力上限</div>
            <input id="heart_limit" type="number" value="4" onfocus="this.select()">
        </div>
    </div>
    <div class="block">
        <div class="verticalBlock" style="display: none">
            <div class="leftDescription">
                <input type="checkbox" id="isProducer" value="first_checkbox">
                <label class="description" for="isProducer">版权</label>
            </div>
            <input id="producer" class="nearDes" style="display: none" type="text" onfocus="this.select()" value="2022 未知作者">
        </div>
        <div class="verticalBlock">
            <div class="leftDescription">
                <input type="checkbox" id="isIllustrator" style="display: none" value="first_checkbox">
                <label class="description" for="isIllustrator">卡牌评价</label>
            </div>
            <input id="illustrator" class="nearDes" type="text" value="">
        </div>
        <div class="verticalBlock">
            <div class="leftDescription" style="display: none">
                <input type="checkbox" id="isCardNumber" value="first_checkbox">
                <label class="description" for="isCardNumber">编号</label>
            </div>
            <input id="cardNumber" class="nearDes" style="display: none" type="text" onfocus="this.select()" value="DIY 001">
        </div>
    </div>
    <div class="block">
        <div class="verticalBlock">
            <div class="description leftDescription">段落数</div>
            <input id="skill_number" type="number" value="2" onfocus="this.select()">
        </div>
    </div>
    <div id="sk1Block" class="block">
        <div class="verticalBlock">
        <div class="description leftDescription">段落1</div>
            <input type="checkbox" id="isItalic1" value="first_checkbox">
            <label class="description description2" for="isItalic1">斜体</label>
        </div>
        <div class="verticalBlock" style="display: none">
            <div class="description leftDescription">技能名</div>
            <input id="sk1n" type="text" onfocus="this.select()" value="仁德">
            <div class="tip traditional_please" style="display: none">请输入繁体</div>
        </div>
        <div class="verticalBlock">
        <div class="description leftDescription" style="display: none">技能描述</div>
            <textarea rows="4" id="sk1" onfocus="this.select()"></textarea>
        </div>
    </div>
    <div id="sk2Block"class="block">
        <div class="verticalBlock">
        <div class="description leftDescription">段落2</div>
            <input type="checkbox" id="isItalic2" value="first_checkbox">
            <label class="description description2" for="isItalic2">斜体</label>
        </div>
        <div class="verticalBlock" style="display: none">
            <div class="description leftDescription">技能名</div>
            <input id="sk2n" type="text" onfocus="this.select()" value="激将">
            <div class="tip traditional_please" style="display: none">请输入繁体</div>
        </div>
        <div class="verticalBlock">
            <div class="description leftDescription" style="display: none">技能描述</div>
            <textarea rows="4" id="sk2" onfocus="this.select()"></textarea>
        </div>
    </div>
        
</div>
</div>

</body>
    <!-- <script type="module" src="./index.js"></script> -->
    <script type="module">
const zh_s = '万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾鼋鼌鼍鼗鼹齄齐齑齿龀龁龂龃龄龅龆龇龈龉龊龋龌龙龚龛龟志制咨只里系范松没尝尝闹面准钟别闲干尽脏拼';
const zh_t = '萬與丑專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼凌減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋里钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽黿鼂鼉鞀鼴齇齊齏齒齔齕齗齟齡齙齠齜齦齬齪齲齷龍龔龕龜誌製谘隻裡係範鬆冇嚐嘗鬨麵準鐘彆閒乾儘臟拚';

function getOffset(text){
    let offsetX = 0;
    let offsetY = 0;
    let color = 'rgba(0, 0, 0)'

    switch (text){
        case "♥":
            offsetX = 0.16;
            offsetY = -0.05;
            color = 'rgba(200, 64, 49)';
            break;
        case "♦":
            offsetX = 0.16;
            offsetY = -0.05;
            color = 'rgba(200, 64, 49)';
            break;
        case "♠":
            offsetX = 0.16;
            offsetY = -0.05;
            break;
        case "♣":
            offsetX = 0.16;
            offsetY = -0.05;
            break;
        case '1':
            offsetX = 0.1;
            break;
        case "f":
            offsetX = 0.1;
            break;
        case "i":
            offsetX = 0.1;
            break;
        case "j":
            offsetX = 0.1;
            break;
        case "l":
            offsetX = 0.1;
            break;
        case 'm':
            offsetX = -0.15;
            break;
        case 't':
            offsetX = 0.1;
            break;
        case 'v':
            offsetX = 0.1;
            break;
        case 'w':
            offsetX = -0.15;
            break;
    }

    return [text, offsetX, offsetY, color];
}

function drawSkillText(ctx, text, fontSize, bold, italic, x, y){
    let font = ""
    font += italic ? "Italic " : "";
    font += bold ? "Bold " : "";
    font += fontSize + "px FangZhengZhunYuan";
    ctx.font = font;

    const res = getOffset(text);
    text = res[0];
    const offsetX = res[1];
    const offsetY = res[2];
    ctx.fillStyle = res[3];

    ctx.fillText(text, x + offsetX * fontSize, y + offsetY * fontSize);
}

export{drawSkillText}

function drawNameChar(ctx, char, fontSize, x, y, lm=0, rm=0, tm=0, bm=0, xo=0, yo=0){
    const hOffset = 0.2;
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    let dpr =  window.devicePixelRatio * 2;
    tempCanvas.width = fontSize * dpr  + 1.0;  // 不加1.0 Safari 会绘制失败
    tempCanvas.height = fontSize * dpr * (1 + hOffset) + 1.0;  // 不加1.0 Safari 会绘制失败

    tempCanvas.style.width = fontSize;
    tempCanvas.style.height = fontSize;
    tempCtx.scale(dpr, dpr)

    tempCtx.font = fontSize + "px JinMeiMaoCaoXing";

    // 描边
    
    /// tempCtx.strokeStyle = "rgb(0, 0, 0)";
    /*
    tempCtx.strokeStyle = "rgb(255, 255, 255)";
    tempCtx.lineWidth = 3.5;
    tempCtx.strokeText(char, 0, fontSize);
    */

    // 内部
    tempCtx.fillStyle = "rgb(0, 0, 0)";
    ///tempCtx.fillStyle = "rgb(255, 255, 255)";

    tempCtx.fillText(char, 0, fontSize);

    // ctx.fillRect(0, 0, 100, 100);


    const sx = fontSize*dpr*lm;
    const sy = fontSize*dpr*tm;
    const sw = fontSize*dpr*(lm+1-rm);
    const sh = fontSize*dpr*(tm+1-bm+hOffset);

    const dx = x+fontSize*lm + xo*fontSize;
    const dy = y+fontSize*tm + yo*fontSize - fontSize;
    const dh = fontSize*(tm+1-bm+hOffset);
    const dw = fontSize*(lm+1-rm);

    ctx.drawImage(tempCanvas, sx, sy, sw, sh, dx, dy, dw, dh);
}


function drawName(ctx, char, x, fontSize, y){
    switch (char){
        case "劭":
            drawNameChar(ctx, "邵", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.5);
            drawNameChar(ctx, "助", fontSize, x+0*fontSize, y+0*fontSize, 0.50, 0);
            break;
        case "詡":
            drawNameChar(ctx, "訂", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.55);
            drawNameChar(ctx, "翔", fontSize, x+0*fontSize, y+0*fontSize, 0.5, 0, 0, 0, -0.04, -0.05);
            break;
        case "瑀":
            drawNameChar(ctx, "玨", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.6);
            drawNameChar(ctx, "齲", fontSize, x+0*fontSize, y+0*fontSize, 0.44, 0, 0, 0, 0, 0.1);
            break;
        case "綝":
            drawNameChar(ctx, "紂", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.59);
            drawNameChar(ctx, "淋", fontSize, x+0*fontSize, y+0*fontSize, 0.33, 0, 0, 0, 0.05, 0);
            break;
        case "琮":
            drawNameChar(ctx, "玨", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.6);
            drawNameChar(ctx, "綜", fontSize, x+0*fontSize, y+0*fontSize, 0.38, 0, 0, 0, 0, 0.05);
            break;
        case "輅":
            drawNameChar(ctx, "軌", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.54);
            drawNameChar(ctx, "胳", fontSize, x+0*fontSize, y+0*fontSize, 0.43, 0, 0, 0, 0, 0);
            break;
        case "禰":
            drawNameChar(ctx, "衫", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.62);
            drawNameChar(ctx, "爾", fontSize, x+0*fontSize, y+0*fontSize, 0, 0, 0, 0, 0.12, 0);
            break;
        case "粲":
            drawNameChar(ctx, "璨", fontSize, x+0*fontSize, y+0*fontSize, 0.35, 0, 0, 0, -0.1, 0);
            break;
        case "儁":
            drawNameChar(ctx, "俊", fontSize, x+0*fontSize, y+0*fontSize, 0, 0.65);
            drawNameChar(ctx, "雋", fontSize, x+0*fontSize, y+0*fontSize, 0, 0, 0, 0, 0.1, 0.05);
            break;
        case "界":
            drawNameChar(ctx, "介", fontSize, x+0*fontSize, y+0*fontSize, 0, 0, 0, 0, -0.05, 0.3);
            drawNameChar(ctx, "異", fontSize, x+0*fontSize, y+0*fontSize, 0, 0, 0, 0.6,-0.05, -0.03);
            break;
        default:
            drawNameChar(ctx, char, fontSize, x, y, 0, 0, 0, 0, 0, 0);
            break;
    }
}

export{drawName};


const cache = [];

function convertToTraditional(str){
    let res = "", idx, resChar;
    for(let char of str){
        if(cache.hasOwnProperty(char)){
            res += cache[char];
        }else{
            idx = zh_s.indexOf(char);
            resChar = (idx === -1) ? char : zh_t[idx];
            cache[char] = resChar;
            res += resChar;
        }
    }
    return res;
}

export{convertToTraditional};

const canvas = document.getElementById('card_preview');
const ctx = canvas.getContext('2d');

const downloadCardButton = document.getElementById("download_card");
let downloadButtonLock = false;  // 避免重复点击下载按钮

const importIllustrationInput = document.getElementById("import_illustration");
const zoomInButton = document.getElementById("zoom_in");
const zoomOutButton = document.getElementById("zoom_out");
const resetScaleButton = document.getElementById("reset_scale");
const translateInput = document.getElementById("translateBox");
const powerSelect = document.getElementById("power_select");
const myLordButton = document.getElementById('myLord');
const scaleNumberInput = document.getElementById("scale_number");

// 体力值与体力上限
const heartInput = document.getElementById('heart');
const heartLimitInput = document.getElementById("heart_limit");
const isHeartLimitButton = document.getElementById("isHeartLimit");
let isHeartLimit = false; // 是否绘制空血

const heroTitleInput = document.getElementById("hero_title");
const heroNameInput = document.getElementById("hero_name");
const skillNumberInput = document.getElementById("skill_number");
const s2ttip = document.getElementById("s2ttip");

const isProducerButton = document.getElementById("isProducer");
let isProducer = false; // 是否绘制制作商
const isIllustratorButton = document.getElementById("isIllustrator");
let isIllustrator = true; // 是否绘制画师
const isCardNumberButton = document.getElementById("isCardNumber");
let isCardNumber = false; // 是否绘制编号

const sizeName = ['dpr', 'clientWidth', 'clientHeight', 'innerWidth', 'innerHeight',
                    'canvasWidth', 'canvasHeight']
const size = new Array(sizeName.length);
let illustration;  // 插画
let miscellaneous; // 杂项

let isS2T = true; // 是否简繁转换

let heart = 4;  // 体力值
let heartLimit = 4; // 体力上限
let power = ""; // 势力
let myLord = false; // 是否是主公
let title = "未知称号"; // 称号
let name = "未知武将"; // 卡牌名

let skillNumber = 2; // 技能数量
let skills = []; // 所有技能

let x = 0;  // 鼠标位置
let y = 0;  // 鼠标位置
let isPressed = false; // 是否按下Canvas
let isTouched = false; // 是否触摸Canvas
let offsetX = 0;  // 拖拽开始时鼠标位置和图片位置的偏移量
let offsetY = 0;  // 拖拽开始时鼠标位置和图片位置的偏移量
let dragFirst = true;

// 懒加载图片
class LazyImage{
    constructor(path) {
        this.path = path;
        this.loading = false;
        this.img = undefined;
    }
    get(){
        if(this.img){
            return this.img;
        }else if(this.loading){
            return undefined;
        }else{
            this.loading = true;
            this.img = new Image();
            this.img.src = this.path;
            this.img.onload = () => {
                this.loading = false;
            }
        }
    }
}

// 外框
class OuterFrame{
    constructor() {
        this.frameName = ['old1_wei', 'old1_shu', 'old1_wu', 'old1_qun', 'old1_shen', 'old1_jin',
            'old1_wei_zhu', 'old1_shu_zhu', 'old1_wu_zhu', 'old1_qun_zhu', 'old1_jin_zhu'];
        this.frame = [];
        for(let name of this.frameName){
            this.frame[name] = new LazyImage('./resources/' + name + '.png');
        }
    }
}
const outerFrame = new OuterFrame(); // 外框

// 插画
class Illustration{
    constructor(img) {
        this.img = img;
        this.width = img.width;
        this.height = img.height;
        this.scale = 1.0;
        this.x = 0;
        this.y = 0;
    }
    changeScale(newScale){
        newScale = newScale * 1.0;
        if(newScale < 0.01){
            newScale = 0.01;
        }
        newScale = Math.floor(newScale * 10000)/10000;
        this.scale = newScale;
    }
}

// 杂项
class Miscellaneous{
    constructor(img) {
        this.img = img;
        // 数组代表 ctx.drawImage 中的 sx, sy, sWidth, sHeight
        this.weiHeartS  = [350, 50,  100, 100];
        this.shuHeartS  = [350, 150, 100, 100];
        this.wuHeartS   = [350, 250, 100, 100];
        this.qunHeartS  = [350, 350, 100, 100];
        this.shenHeartS = [350, 450, 100, 100];
        this.jinHeartS = [350, 550, 100, 100];
        this.weiHeartLimitS  = [450, 50,  100, 100];
        this.shuHeartLimitS  = [450, 150, 100, 100];
        this.wuHeartLimitS   = [450, 250, 100, 100];
        this.qunHeartLimitS  = [450, 350, 100, 100];
        this.shenHeartLimitS = [450, 450, 100, 100];
        this.jinHeartLimitS = [450, 550, 100, 100];

        this.weiSkillBox  = [100, 50, 200, 100];
        this.shuSkillBox  = [100, 150, 200, 100];
        this.wuSkillBox   = [100, 250, 200, 100];
        this.qunSkillBox  = [100, 350, 200, 100];
        this.shenSkillBox = [100, 450, 200, 100];
        this.jinSkillBox = [100, 550, 200, 100];

        this.weiColor = "#ccd5ec"
        this.shuColor = "#e9cfb2"
        this.wuColor = "#d6e3bf";
        this.qunColor = "#d2cbc8";
        this.shenColor = "#c2bd64";
        this.jinColor = "#e3b5f1";
    }
}

// 技能
class Skill{
    constructor(name, text){
        this.name = name;
        this.text = text;
        this.isBold = false;
        this.isItalic = false;
    }
}

// 按钮事件：下载（保存）卡牌到本地
downloadCardButton.onclick = downloadCard;

function downloadCard(){
    function download(){
        const downloadLink = document.createElement('a');
        // const date = new Date();
        let fileName = name;
        // fileName += Math.floor(date.getTime() / 1000);
        fileName += ".png";
        downloadLink.setAttribute('download', fileName);
        canvas.toBlob(
            function(blob){
                const url = URL.createObjectURL(blob);
                downloadLink.setAttribute('href', url);
                downloadLink.click();
            }
        );
    }

    if(downloadButtonLock){
        alert("正在处理，请勿重复点击下载按钮");
    }else{
        downloadButtonLock = true;
        // 准备好要发送的数据
        const cardInfo = {};
        cardInfo['version'] = "" + document.getElementById("AppName").innerText;
        if(isProducer){
            cardInfo['producer'] = "" + document.getElementById("producer").value;
        }
        if(isIllustrator){
            cardInfo['illustrator'] = "" + document.getElementById("illustrator").value;
        }
        if(isCardNumber){
            cardInfo['cardNumber'] = "" + document.getElementById("cardNumber").value;

        }
        if(myLord){
            cardInfo['myLord'] = "主公";
        }
        cardInfo['power'] = "" + power;
        cardInfo['name'] = "" + name;
        cardInfo['heart'] = "" + heart;
        if(isHeartLimit){
            cardInfo['heartLimit'] = "" + heartLimit;
        }
        cardInfo['title'] = "" + title;
        cardInfo['skillNumber'] = "" + skillNumber;
        for(let i=0; i < skillNumber; i++){
            cardInfo['skillName' + (i+1)] = skills[i].name;
            cardInfo['skill' + (i+1)] = skills[i].text;
        }

        let cardJson = JSON.stringify(cardInfo);
        let timeStamp = new Date().getTime();

        ///
        /*

        // 发送
        $.ajax({
            type: "POST",
            // 服务器地址
            url: "https://service-8rupwbi8-1253139667.gz.apigw.tencentcs.com/release/generate_sgs_card",  // 新
            // url: "https://service-6suhxcdg-1253139667.gz.apigw.tencentcs.com/release/generate_sgs_card",  // 旧
            data: cardJson,
            contentType: "application/json; charset=utf-8",
            success: function(msg){
                // alert(msg);
                // alert((new Date().getTime() - timeStamp) + "ms")
                download();
                downloadButtonLock = false;
            },
            error: function(errMsg) {
                downloadButtonLock = false;
                const r = confirm("保存失败，是否重试？");
                if(r == true){
                    downloadCard();
                }
            }
        });
        */
        $.ajax({
            type: "POST",
            // 服务器地址
            url: "https://service-8rupwbi8-1253139667.gz.apigw.tencentcs.com/release/generate_sgs_card",  // 新
            // url: "https://service-6suhxcdg-1253139667.gz.apigw.tencentcs.com/release/generate_sgs_card",  // 旧
            data: cardJson,
            contentType: "application/json; charset=utf-8",
            success: function(msg){
                alert(msg);
                alert((new Date().getTime() - timeStamp) + "ms")
                download();
                downloadButtonLock = false;
            },
            error: function(errMsg) {
                downloadButtonLock = false;
                alert(errMsg);
                alert((new Date().getTime() - timeStamp) + "errms")
                download();
                downloadButtonLock = false;ownloadCard();
            }
        });
        download();
        downloadButtonLock = false;
    }
}

// 按钮事件：导入插画
importIllustrationInput.onchange = function(){
    const curFiles = importIllustrationInput.files;
    if(curFiles.length > 0){
        const url = URL.createObjectURL(curFiles[0]);
        importIllustration(url);
    }
}

// 按钮事件：放大插画
zoomInButton.onclick = function(){
    if(typeof(illustration) != "undefined"){
        illustration.changeScale(illustration.scale * 1.25);
        refresh_scale_text(illustration, scaleNumberInput);
    }
}

// 按钮事件：缩小插画
zoomOutButton.onclick = function(){
    if(typeof(illustration) != "undefined"){
        illustration.changeScale(illustration.scale * 0.8);
        refresh_scale_text(illustration, scaleNumberInput);
    }
}

// 按钮事件：重置图像缩放
resetScaleButton.onclick = function(){
    if(typeof(illustration) != "undefined"){
        illustration.x = 0;
        illustration.y = 0;
        illustration.scale = 1.0;
    }
}

// 按钮事件：是否简繁转换
translateInput.onchange = function(){
    isS2T = translateInput.checked;
    if(isS2T){
        for(let i of document.getElementsByClassName("traditional_please")){
            i.style = "display: none";
        }
        s2ttip.style = ""
    }else{
        for(let i of document.getElementsByClassName("traditional_please")){
            i.style = "";
            s2ttip.style = "display: none"
        }
    }
}

// 点击按钮切换显示状态
function switchDisplay(display, element){
    if(display){
        element.style = "";
    }else{
        element.style = "display: none";
    }
}

// 按钮事件：是否显示版权信息（作者）
isProducerButton.onchange = function(){
    isProducer = isProducerButton.checked;
    switchDisplay(isProducer, document.getElementById("producer"));
}

// 按钮事件：是否显示画师
isIllustratorButton.onchange = function(){
    isIllustrator = isIllustratorButton.checked;
    switchDisplay(isIllustrator, document.getElementById("illustrator"));
}

// 按钮事件：是否显示编号
isCardNumberButton.onchange = function(){
    isCardNumber = isCardNumberButton.checked;
    switchDisplay(isCardNumber, document.getElementById("cardNumber"));
}

// 输入框事件：更改技能数量
skillNumberInput.onchange = function(){
    const editor = document.getElementById("editor");
    let number = skillNumberInput.value;
    number = Math.floor(number);
    number = number < 0 ? 0 : number;
    number = number > 10 ? 10 : number;
    skillNumberInput.value = number;
    skillNumber = number;
    for(let i = 0; i < number; i++){
        const skBlock = document.getElementById("sk" + (i+1) + "Block");
        if(skBlock){
            skBlock.style = "";
        }else{
            const style = isS2T ? "display: none" : "";
            const content =
                "<div id=\"sk" + (i+1) + "Block\" class=\"block\">\n" +
                "        <div class=\"verticalBlock\">" +
                "        <div class=\"description leftDescription\">段落" + (i+1) + "</div>\n" +
                "            <input type=\"checkbox\" id=\"isItalic" + (i+1) + "\" value=\"first_checkbox\">" +
                "            <label class=\"description description2\" for=\"isItalic" + (i+1) + "\">斜体</label>" +
                "        </div>" +
                "        <div style=\"clear:both\"></div>\n" +
                "        <div class=\"verticalBlock\" style=\"display: none\">" +
                "            <div class=\"description leftDescription\">技能名</div>\n" +
                "            <input id=\"sk" + (i+1) + "n\" type=\"text\" onfocus=\"this.select()\" value=\"\">\n" +
                "            <div class=\"tip traditional_please\" style=\"" + style +"\">请输入繁体</div>" +
                "        </div>" +
                "        <div class=\"verticalBlock\">" +
                "            <div class=\"description leftDescription\" style=\"display: none\">技能描述</div>\n" +
                "            <textarea rows=\"4\" id=\"sk" + (i+1) + "\" onfocus=\"this.select()\"></textarea>" +
                "        </div>" +
                "    </div>";
            editor.insertAdjacentHTML('beforeend', content);
        }
    }
    for(let i = number; i < 10; i++ ){
        const skBlock = document.getElementById("sk" + (i+1) + "Block");
        if(skBlock){
            skBlock.style = "display: none";
        }
    }
}

// 输入框事件：修改缩放比例
scaleNumberInput.onchange = function(){
    if(typeof(illustration) != "undefined"){
        illustration.changeScale(scaleNumberInput.value / 100);
        refresh_scale_text(illustration, scaleNumberInput);
    }
}

// 输入框事件：修改体力值
heartInput.onchange = function(){
    let value = Math.floor(heartInput.value);
    value = value < 1 ? 1 : value;
    value = value > 100 ? 100 : value;
    if(!isHeartLimit || value > heartLimit){
        heartLimit = value;
        heartLimitInput.value = value;
    }
    heartInput.value = value;
    heart = value;
}

// 按钮事件：是否显示空血
isHeartLimitButton.onchange = () => {
    if(isHeartLimitButton.checked){
        isHeartLimit = true;
        document.getElementById('heartLimitVBlock').style = "";
    }else{
        isHeartLimit = false;
        heartLimit = heart;
        document.getElementById('heartLimitVBlock').style = "display: none";
    }
}

// 输入框事件：修改体力上限
heartLimitInput.onchange = function(){
    let value = Math.floor(heartLimitInput.value);
    value = Math.floor(value);
    value = value < 1 ? 1 : value;
    value = value > 100 ? 100 : value;
    if(value < heart){
        heart = value;
        heartInput.value = value;
    }
    heartLimitInput.value = value;
    heartLimit = value;
}

// 禁用默认的触屏滚动
canvas.addEventListener('touchmove',
    function(e){e.preventDefault();},
    {passive: false});

// 更新当前鼠标位置
canvas.onmousemove = function(e){
    x = e.offsetX;
    y = e.offsetY;
}

// 更新当前鼠标位置
canvas.ontouchmove = function(e){
    x = e.changedTouches[0].clientX;
    y = e.changedTouches[0].clientY;
}

// 检测鼠标按下
canvas.onmousedown = function(){
    isPressed = true;
    dragFirst = true;
}

// 检测鼠标抬起
canvas.onmouseup = function(){
    isPressed = false;
}

// 检测触摸按下
canvas.ontouchstart = function(e){
    x = e.changedTouches[0].clientX;
    y = e.changedTouches[0].clientY;
    isTouched = true;
    dragFirst = true;
}

// 检测鼠标抬起
canvas.ontouchend = function(){
    isTouched = false;
}

// 刷新缩放输入框的文本
function refresh_scale_text(illustration, scaleNumberInput){
    scaleNumberInput.value = Math.floor(illustration.scale * 100);
}

// 获取窗口大小
function getWindowSize(){
    size[0] = window.devicePixelRatio;
    size[1] = document.body.clientWidth;
    size[2] = document.body.clientHeight;
    size[3] = window.innerWidth;
    size[4] = window.innerHeight;
    size[5] = canvas.width;
    size[6] = canvas.height;
}

// 设置Canvas大小，返回逻辑分辨率
function setCanvasSize(canvas){
    let dpr = window.devicePixelRatio * 2;  // 超分辨率绘制，提高绘制效果
    const ctx = canvas.getContext('2d');
    const clientWidth = document.body.clientWidth;
    const logicalWidth = 400;
    const logicalHeight = logicalWidth * (88/63);
    const styleWidth = Math.min(400, clientWidth);
    const styleHeight = styleWidth * (88/63);

    canvas.width = logicalWidth * dpr;
    canvas.height = logicalHeight * dpr;
    canvas.style.width = styleWidth + 'px';
    canvas.style.height = styleHeight + 'px';
    ctx.scale(dpr, dpr);

    return [logicalWidth, logicalHeight];
}


// 绘制外框
function drawOuterFrame(ctx, power, myLord, outerFrame, logicalWidth, logicalHeight){
    if(outerFrame){
        let img = undefined;
        if(power === "魏" && myLord){
            img =  outerFrame.frame['old1_wei_zhu'].get();
        }else if(power === "魏" && !myLord){
            img =  outerFrame.frame['old1_wei'].get();
        }else if(power === "蜀" && myLord){
            img =  outerFrame.frame['old1_shu_zhu'].get();
        }else if(power === "蜀" && !myLord){
            img =  outerFrame.frame['old1_shu'].get();
        }else if(power === "吴" && myLord){
            img =  outerFrame.frame['old1_wu_zhu'].get();
        }else if(power === "吴" && !myLord){
            img =  outerFrame.frame['old1_wu'].get();
        }else if(power === "群" && myLord){
            img =  outerFrame.frame['old1_qun_zhu'].get();
        }else if(power === "群" && !myLord){
            img =  outerFrame.frame['old1_qun'].get();
        }else if(power === "晋" && myLord){
            img =  outerFrame.frame['old1_jin_zhu'].get();
        }else if(power === "晋" && !myLord){
            img =  outerFrame.frame['old1_jin'].get();
        }else if(power === "神"){
            img =  outerFrame.frame['old1_shen'].get();
        }else{
            console.error("没有对应的势力！");
        }
        if(img){
            const drawWidth = logicalWidth * 1.0;
            const drawHeight = drawWidth * img.height / img.width;
            const drawX = 0;
            const drawY = 0;
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }
    }
}

// 导入插画
function importIllustration(path){
    const img = new Image();
    img.src = path;
    img.onload = function(){
        illustration = new Illustration(img);
    }
}

// 导入杂项
function importMiscellaneous(path){
    if(typeof(miscellaneous) == "undefined"){
        const path = "./resources/miscellaneous.png";
        const img = new Image();
        img.src = path;
        img.onload = function(){
            miscellaneous = new Miscellaneous(img);
        }
    }
}

// 绘制插画
function drawIllustration(ctx, illustration, logicalWidth, logicalHeight){
    if(typeof(illustration) != "undefined"){
        const cardRatio = 1.0 * logicalWidth / logicalHeight;
        const illustrationRatio = 1.0 * illustration.width / illustration.height;
        let drawWidth = 0;
        let drawHeight = 0;
        /// 1.0 改为 0.4
        if(cardRatio < illustrationRatio){ // 如果图片更宽，则高度和卡面设为一致
            drawHeight = 0.4 * logicalHeight * illustration.scale;
            drawWidth = drawHeight * illustrationRatio;
        }else{  // 如果图片更高，则宽度和卡面设为一致
            drawWidth = 0.4 * logicalWidth * illustration.scale;
            drawHeight = drawWidth / illustrationRatio;
        }
        const centerX = logicalWidth*1.0/2;
        const centerY = logicalHeight*1.0/2-60; ///-60
        let drawX = centerX + illustration.x - drawWidth/2;
        let drawY = centerY + illustration.y - drawHeight/2;


        ctx.drawImage(illustration.img, drawX, drawY, drawWidth, drawHeight);
    }
}

// 绘制体力与体力上限
function drawHeartLimit(type, power, heartLimit, heart){
    const length = 40;
    const dx = 100;
    const dy = 15;
    let offset = 20;
    const maxHeartNumber = 12;
    if(heartLimit >= maxHeartNumber){
        offset = 20 * (maxHeartNumber - 1) / (heartLimit - 1);
    }
    if(type === "old"){
        if(miscellaneous){
            let S1, S2;
            if(power === "神" || myLord){
                S1 = miscellaneous.shenHeartS;
                S2 = miscellaneous.shenHeartLimitS;
            }else if(power === "魏"){
                S1 = miscellaneous.weiHeartS;
                S2 = miscellaneous.weiHeartLimitS;
            }else if(power === "蜀"){
                S1 = miscellaneous.shuHeartS;
                S2 = miscellaneous.shuHeartLimitS;
            }else if(power === "吴"){
                S1 = miscellaneous.wuHeartS;
                S2 = miscellaneous.wuHeartLimitS;
            }else if(power === "群"){
                S1 = miscellaneous.qunHeartS;
                S2 = miscellaneous.qunHeartLimitS;
            }else if(power === "晋"){
                S1 = miscellaneous.jinHeartS;
                S2 = miscellaneous.jinHeartLimitS;
            }else{
                console.error("没有对应的势力！");
            }
            if(S1 && S2){
                for(let i = 0; i < heart; i++){
                    ctx.drawImage(miscellaneous.img, S1[0], S1[1], S1[2], S1[3], dx+offset*i, dy, length, length);
                }
                for(let i = heart; i < heartLimit; i++){
                    ctx.drawImage(miscellaneous.img, S2[0], S2[1], S2[2], S2[3], dx+offset*i, dy, length, length);
                }
            }
        }
    }
}

// 绘制称号和卡牌名
function drawTitleAndName(ctx, title, name, skillTop){
    let titleNum = 0;
    for(let i of title){
        titleNum += 1;
    }
    let nameNum = 0;
    for(let i of name){
        nameNum += 1;
    }

    skillTop -= 16;
    let ratio = 0.5; // 称号与卡牌名的比例
    if(nameNum > 3){
        ratio = 0.35
    }

    let nameBottomY = skillTop < 380 ? skillTop : 380; // 名字的最下端
    let titleTopY = 110; // 称号的最上端（固定）
    let titleBottomY = titleTopY + (nameBottomY - titleTopY) * ratio; // 称号的最下端
    /// let nameTopY = titleBottomY;  // 名字的最上端
    let nameTopY = 110;

    // 绘制称号
    let offset = Math.floor((titleBottomY - titleTopY) / titleNum);
    offset *= 0.9
    offset = offset > 24 ? 24 : offset;
    let x = power === "神" ? 355 - offset / 2 : 61 - offset / 2;
    let y = titleTopY + Math.floor((titleBottomY - titleTopY)*1.0 / titleNum / 2.0 + offset/2.0);
    ctx.font = offset + "px DFNewChuan";
    const lineWidth =2.5; // 称号描边宽度
    if(isS2T){
        title = convertToTraditional(title);
    }
    for(let i in title){
        ctx.strokeStyle = "rgb(0, 0, 0)";
        ctx.lineWidth = lineWidth;
        ctx.strokeText(title[i], x, y + offset * i);

        if(myLord){
            if(power === "魏"){
                ctx.fillStyle = 'rgb(41,88,155)';
            }else if(power === "蜀"){
                ctx.fillStyle = 'rgb(175,98,36)';
            }else if(power === "吴"){
                ctx.fillStyle = 'rgb(62,109,31)';
            }else if(power === "群"){
                ctx.fillStyle = 'rgb(118,118,118)';
            }else if(power === "晋"){
                ctx.fillStyle = 'rgb(104,19,129)';  // 待修改
            }else{
                console.error("势力\"" + power + "\"不存在主公！");
            }
        }else{
            ctx.fillStyle = "rgb(255, 255, 0)";
        }
        ctx.fillText(title[i], x, y + offset * i);
    }

    // 绘制卡牌名
    ///
    /*
    offset = Math.floor((nameBottomY - nameTopY) / nameNum);
    if(nameNum <= 2){
        offset *= 0.85;
    }
    offset = offset > 57 ? 57 : offset;
    x = power === "神" ? 355 - offset / 2 : 60 - offset / 2;
    y = nameTopY + Math.floor((nameBottomY - nameTopY) / nameNum / 2.0 + offset * 0.3);
    */
    offset = Math.floor((380 - 110) / 4);
    offset = offset > 57 ? 57 : offset;
    x = 200 - nameNum * 27.5;
    y = 80;
    if(isS2T){
        name = convertToTraditional(name);
    }
    for(let i in name){
        /// drawName(ctx, name[i], x, offset, y + offset * i)
        drawName(ctx, name[i], x + offset * i, offset, y)
    }
    
}

// 拖拽插画
function dragIllustration(){
    if(typeof(illustration) != "undefined" && (isPressed || isTouched)){
        if(dragFirst == true){
            offsetX = illustration.x - x;
            offsetY = illustration.y - y;
            dragFirst = false;
        }else{
            illustration.x = x + offsetX;
            illustration.y = y + offsetY;
        }
    }
}

// 刷新内容
function refreshAll(){
    // 刷新势力名
    power = powerSelect.value;
    // 刷新是否为主公
    myLord = power === '神' ? false : myLordButton.checked;

    skills = []; // 清空技能列表
    for(let i = 0; i < skillNumber; i++){
        const skn = document.getElementById("sk" + (i+1) + "n");
        const sk = document.getElementById("sk" + (i+1));
        const skill = new Skill(skn.value, sk.value);
        for(let j in skill.text){
            if(j == 2 && skill.text[j] === "技"){
                skill.isBold = true;
            }else if(j > 2){
                break;
            }
        }
        const checked = document.getElementById('isItalic' + (i+1)).checked;
        if(checked){
            skill.isItalic = true;
        }
        skills.push(skill);
    }
    title = heroTitleInput.value;
    name = heroNameInput.value;
}

// 绘制技能名与技能
function drawSkill(ctx, skills){
    // 与绘制技能有关的所有属性
    class SkillTextDrawingAttr{
        constructor() {
            this.skillTopX = 50;  /// 技能区最顶部的X坐标104
            this.skillTopMinY = 460; // 技能区最顶部的Y坐标不得低于此值435
            this.sillTopY = this.skillTopMinY; // 技能区最顶部的Y坐标
            this.skillBottomY = 500; // 技能区最底部的Y坐标

            this.maxHeight = (this.skillBottomY - this.sillTopY) * 3;  // 技能区最大高度
            this.skillWidth = 290;  // 技能区宽度238
            this.indent = 0.5; // 首字缩进为0.25个汉字宽度
            this.paragraphSpacing = 0.3;  // 段间距，实际段间距为此值*yOffset

            this.fontSize = 18;  // 技能字号12
            this.yOffset = this.fontSize * 1.2;  // 行间距，当字体缩小时变为与字体大小相同

        }
    }

    const skillTextDrawingAttr = new SkillTextDrawingAttr();  // 与绘制技能有关的所有属性
    let skillBoxY = [];  // 技能名外框的位置

    // 绘制一行文本
    function drawLine(ctx, firstLine, lastLine, lineString, skillTextDrawingAttr, line, bold, italic, i){
        let lineCharNum = 0;  // 这一行的文字数量
        for(let char of lineString){
            lineCharNum += char.charCodeAt(0) > 255 ? 2 : 1;
        }
        let xOffset;  // X偏移量
        let cur = skillTextDrawingAttr.skillTopX;  // 当前绘制的位置（X坐标）

        // 确定文字间距和起始坐标
        if(firstLine && !lastLine){
            xOffset = (skillTextDrawingAttr.skillWidth - skillTextDrawingAttr.indent * skillTextDrawingAttr.fontSize) / (lineCharNum - 1);
            cur += skillTextDrawingAttr.indent * skillTextDrawingAttr.fontSize;
        }else if(firstLine && lastLine){
            xOffset = skillTextDrawingAttr.fontSize / 2;
            cur += skillTextDrawingAttr.indent * skillTextDrawingAttr.fontSize;
        }else if(lastLine){
            xOffset = skillTextDrawingAttr.fontSize / 2;
        }
        else{
            xOffset = skillTextDrawingAttr.skillWidth / (lineCharNum - 1);
        }

        for(let k in lineString){
            let charBold = false;
            if(firstLine && bold && k < 3){
                charBold = true;
            }else{
                charBold = false;
            }
            drawSkillText(ctx, lineString[k], skillTextDrawingAttr.fontSize, charBold, italic, cur, skillTextDrawingAttr.sillTopY + skillTextDrawingAttr.yOffset * line + i * skillTextDrawingAttr.yOffset * skillTextDrawingAttr.paragraphSpacing);
            cur += lineString[k].charCodeAt(0) > 255 ? 2 * xOffset : 1 * xOffset;
        }
    }

    // 遍历所有文字，也可以绘制文字
    function iterationText(draw){
        let line = 0;  // 当前行数
        let cur = skillTextDrawingAttr.indent * skillTextDrawingAttr.fontSize;  // 当前绘制的位置（X坐标）
        let isFirstLine = true;  // 用来判断是否是首行
        let hasReturn = false;  // 避免重复换行
        skillBoxY = [];
        // 绘制所有技能
        for(let i in skills){
            skillBoxY.push(skillTextDrawingAttr.sillTopY + skillTextDrawingAttr.yOffset * line + i * skillTextDrawingAttr.yOffset * skillTextDrawingAttr.paragraphSpacing);
            let lineOfThisSkill = 0;
            let lineString = [];
            let skillCharNum = 0;
            for(let j in skills[i].text){
                skillCharNum += 1;
            }

            // 绘制每个技能
            for(let j in skills[i].text){
                const char = skills[i].text[j];
                if(draw && char.charCodeAt(0) != 65039){  // 忽略变体选择符
                    lineString.push(char);
                }
                cur += char.charCodeAt(0) > 255 ? skillTextDrawingAttr.fontSize : skillTextDrawingAttr.fontSize/2;
                if(cur > skillTextDrawingAttr.skillWidth){
                    // 绘制非最后一行
                    if(draw){
                        drawLine(ctx, isFirstLine, false, lineString, skillTextDrawingAttr, line, skills[i].isBold, skills[i].isItalic, i)
                    }

                    lineString = [];
                    lineOfThisSkill += 1;
                    line += 1;
                    cur = 0;
                    isFirstLine = false;
                    hasReturn = true;
                }else{
                    hasReturn = false;
                }
            }

            // 绘制最后一行
            if(draw){
                drawLine(ctx, isFirstLine, true, lineString, skillTextDrawingAttr, line, skills[i].isBold, skills[i].isItalic, i)
            }

            cur = skillTextDrawingAttr.indent * skillTextDrawingAttr.fontSize;
            isFirstLine = true;
            line = hasReturn ? line : line + 1;
            if(lineOfThisSkill < 1 || lineOfThisSkill === 1 && hasReturn){
                line += 1;
            }
        }

        // 更改第一行的位置
        skillTextDrawingAttr.sillTopY = skillTextDrawingAttr.skillBottomY;
        skillTextDrawingAttr.sillTopY -= (line-1) * skillTextDrawingAttr.yOffset;
        skillTextDrawingAttr.sillTopY -= skillTextDrawingAttr.paragraphSpacing * skillTextDrawingAttr.yOffset * (skills.length-1);
        skillTextDrawingAttr.sillTopY = skillTextDrawingAttr.skillTopMinY < skillTextDrawingAttr.sillTopY ? skillTextDrawingAttr.skillTopMinY : skillTextDrawingAttr.sillTopY;
        return line;
    }

    // 第一次遍历，仅用于统计行数
    let numLine = iterationText(false);
    while (numLine * skillTextDrawingAttr.yOffset + skills.length * skillTextDrawingAttr.yOffset * skillTextDrawingAttr.paragraphSpacing > skillTextDrawingAttr.maxHeight){
        skillTextDrawingAttr.fontSize -= 1;
        if(skillTextDrawingAttr.fontSize === 1){
            break;
        }
        skillTextDrawingAttr.yOffset = skillTextDrawingAttr.fontSize;
        numLine = iterationText(false)
    }

    ctx.font = "" + skillTextDrawingAttr.fontSize + "px FangZhengZhunYuan";
    ctx.fillStyle = "rgb(0, 0, 0)";

    // 第二次遍历，获取顶部位置
    iterationText(false);

    // 绘制技能底框
    ///
    /*
    if(typeof(skillBoxY[0]) != "undefined"){
        const alpha = 0.8;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        if(typeof(miscellaneous) != "undefined"){
            let color;
            if(power === "魏"){
                color = miscellaneous.weiColor;
            }else if(power === "蜀"){
                color = miscellaneous.shuColor;
            }else if(power === "吴"){
                color = miscellaneous.wuColor;
            }else if(power === "群"){
                color = miscellaneous.qunColor;
            }else if(power === "神"){
                color = miscellaneous.shenColor;
            }else if(power === "晋"){
                color = miscellaneous.jinColor;
            }else{
                color = miscellaneous.qunColor;
                console.error("不存在势力\"" + power + "\"对应的技能框颜色");
            }
            let r = color.substr(1, 2);
            let g = color.substr(3, 2);
            let b = color.substr(5, 2);
            r = parseInt(r, 16);
            g = parseInt(g, 16);
            b = parseInt(b, 16);
            ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
            ctx.strokeStyle = ctx.fillStyle;
        }

        const drawY = skillBoxY[0]-23;
        const drawX = 84;
        const drawWidth = 275;
        const drawHeight = 520 - drawY;
        const corner = 10;
        const margin = 3;
        ctx.beginPath();
        ctx.moveTo(drawX, drawY + corner);
        ctx.lineTo(drawX + corner, drawY + corner);
        ctx.lineTo(drawX + corner, drawY);

        ctx.lineTo(drawX + drawWidth - corner, drawY);
        ctx.lineTo(drawX + drawWidth - corner, drawY + corner);
        ctx.lineTo(drawX + drawWidth, drawY + corner);

        ctx.lineTo(drawX + drawWidth, drawY + drawHeight - corner);
        ctx.lineTo(drawX + drawWidth - corner, drawY + drawHeight - corner);
        ctx.lineTo(drawX + drawWidth - corner, drawY + drawHeight);

        ctx.lineTo(drawX + corner, drawY + drawHeight);
        ctx.lineTo(drawX + corner, drawY + drawHeight - corner);
        ctx.lineTo(drawX, drawY + drawHeight - corner);

        ctx.lineTo(drawX, drawY + corner);
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(drawX + margin, drawY + corner + margin);
        ctx.lineTo(drawX + corner + margin, drawY + corner + margin);
        ctx.lineTo(drawX + corner + margin, drawY + margin);

        ctx.lineTo(drawX + drawWidth - corner - margin, drawY + margin);
        ctx.lineTo(drawX + drawWidth - corner - margin, drawY + corner + margin);
        ctx.lineTo(drawX + drawWidth - margin, drawY + corner + margin);

        ctx.lineTo(drawX + drawWidth - margin, drawY + drawHeight - corner - margin);
        ctx.lineTo(drawX + drawWidth - corner - margin, drawY + drawHeight - corner - margin);
        ctx.lineTo(drawX + drawWidth - corner - margin, drawY + drawHeight - margin);

        ctx.lineTo(drawX + corner + margin, drawY + drawHeight - margin);
        ctx.lineTo(drawX + corner + margin, drawY + drawHeight - corner - margin);
        ctx.lineTo(drawX + margin, drawY + drawHeight - corner - margin);

        ctx.lineTo(drawX + margin, drawY + corner + margin);
        ctx.fill();
    }
    */

    ctx.fillStyle = 'rgb(0, 0, 0)';
    // 第三次遍历，绘制文字
    iterationText(true);

    // 绘制技能名外框与技能名
    if(typeof(miscellaneous) != "undefined"){
        for(let i in skillBoxY){
            const length = 68;
            let S;
            if(power === "魏"){
                S = miscellaneous.weiSkillBox;
            }else if(power === "蜀"){
                S = miscellaneous.shuSkillBox;
            }else if(power === "吴"){
                S = miscellaneous.wuSkillBox;
            }else if(power === "群"){
                S = miscellaneous.qunSkillBox;
            }else if(power === "神"){
                S = miscellaneous.shenSkillBox;
            }else if(power === "晋"){
                S = miscellaneous.jinSkillBox;
            }else{
                S = miscellaneous.qunSkillBox;
                console.error("不存在势力\"" + power + "\"对应的技能名外框！");
            }

            if(power === "神"){
                ctx.fillStyle = "rgb(239, 227, 111)"
            }else{
                ctx.fillStyle = "rgb(0, 0, 0)"
            }
            ctx.drawImage(miscellaneous.img, S[0], S[1], S[2], S[3], skillTextDrawingAttr.skillTopX-69, skillBoxY[i]-22, length, length/2);
            ctx.font = "20px FangZhengLiShu";
            let str = skills[i].name.substr(0, 2);
            if(isS2T){
                str = convertToTraditional(str);
            }
            ctx.fillText(str, skillTextDrawingAttr.skillTopX-57, skillBoxY[i]+1.5);
        }
    }

    return skillBoxY.length > 1 ? skillBoxY[0] : 65534;
}


// 绘制底部信息
function drawBottomInfo(ctx, isProducer, isIllustrator){
    let str = "";
    if(isProducer){
        str += "" + document.getElementById("producer").value;
        str += ".  ";
    }
    if(isIllustrator){
        /// 
        str += document.getElementById("illustrator").value;
    }
    ctx.font = "12px FangZhengZhunYuan";
    let leftPos = 85;
    let rightPos = 340;
    if(power === "神"){
        ctx.fillStyle = 'rgb(255, 255, 255)';
        leftPos = 150;
        rightPos = 370;
    }else{
        ctx.fillStyle = 'rgb(0, 0, 0)';
        leftPos = 85;
        rightPos = 350;
    }
    ///
    ctx.fillText(str, rightPos-70-str.length*8, 539);

    if(isCardNumber){
        str = "" + document.getElementById("cardNumber").value;
        ctx.textAlign = 'right';
        ctx.fillText(str, rightPos, 539);
    }

}

// 绘制版本信息
function drawVersionInformation(ctx){
    const drawX = 20;
    const drawY = 553;
    ctx.textAlign = 'left';
    ctx.font = "8px FangZhengZhunYuan";
    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
    const info = "" + document.getElementById("AppName").innerText;
    ctx.fillText(info, drawX, drawY);
}

let oldmsg = "";
// 绘图
function draw(){
    getWindowSize();

    // 获取技能名和技能描述
    refreshAll();

    // 获取Canvas的物理分辨率
    let logicalSize = setCanvasSize(canvas);
    const logicalWidth = logicalSize[0];
    const logicalHeight = logicalSize[1];

    // 拖拽插画
    dragIllustration();


    // 绘制外框
    if(typeof(outerFrame) != "undefined"){
        drawOuterFrame(ctx, power, myLord, outerFrame, logicalWidth, logicalHeight);
    }

    ///

    // 绘制插画
    if(typeof(illustration) != "undefined"){
        drawIllustration(ctx, illustration, logicalWidth, logicalHeight);
    }

    // 绘制体力
    drawHeartLimit("old", power, heartLimit, heart);

    // 绘制技能
    let skillTop = drawSkill(ctx, skills);

    // 绘制称号
    drawTitleAndName(ctx, title, name, skillTop);

    // 绘制底部信息
    drawBottomInfo(ctx, isProducer, isIllustrator);

    // 绘制版本信息
    drawVersionInformation(ctx);

    window.requestAnimationFrame(draw);
}

draw();
importIllustration("./resources/刘备-六星耀帝.png");
importMiscellaneous();
    </script>

</html>